#pragma kernel ExternalForces
#pragma kernel UpdateSpatialHash 
#pragma kernel UpdateBoids
#pragma kernel UpdatePositions

#include "./SpatialHash.hlsl"

static const int NumThreads = 64;

// Buffers
RWStructuredBuffer<float2> Positions;
RWStructuredBuffer<float2> PredictedPositions;
RWStructuredBuffer<float2> Velocities;
RWStructuredBuffer<float2> Densities;
RWStructuredBuffer<uint3> SpatialIndices;
RWStructuredBuffer<uint> SpatialOffsets;

// Simulation Settings
const uint numParticles;
const float gravity;
const float deltaTime;
const float wallBounciness; 

// Fluid / Swarm Settings
const float sensorRadius; 
const float idealNeighborCount;
const float pressureMultiplier;
const float viscosity;
const float drag;

// Stability Settings
const float collisionRadius;
const float collisionStiffness;// The kick multiplier
const float verticalSupport;

// Limits
const float maxSpeed;
const float maxForce;

// Interaction / Bounds
const float2 boundsSize;
const float2 interactionInputPoint;
const float interactionInputStrength;
const float interactionInputRadius;
const float2 obstacleSize;
const float2 obstacleCentre;
 

// --- Kernel 1: External Forces ---
[numthreads(NumThreads, 1, 1)]
void ExternalForces(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    float2 force = float2(0, gravity);

    if (interactionInputStrength != 0)
    {
        float2 offset = interactionInputPoint - Positions[id.x];
        float sqrDst = dot(offset, offset);
        if (sqrDst < interactionInputRadius * interactionInputRadius)
        {
            float dst = sqrt(sqrDst);
            float2 dir = offset / dst;
            float t = 1 - (dst / interactionInputRadius);
            force += dir * (interactionInputStrength * t);
        }
    }

    Velocities[id.x] += force * deltaTime;
    PredictedPositions[id.x] = Positions[id.x] + Velocities[id.x] * (1.0 / 120.0);
}

// --- Kernel 2: Spatial Hash ---
[numthreads(NumThreads, 1, 1)]
void UpdateSpatialHash(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    SpatialOffsets[id.x] = numParticles;
    
    // Use sensorRadius for the grid size
    int2 cell = GetCell2D(PredictedPositions[id.x], sensorRadius);
    uint hash = HashCell2D(cell);
    uint key = KeyFromHash(hash, numParticles);
    
    SpatialIndices[id.x] = uint3(id.x, hash, key);
}

// --- Kernel 3: Swarm Physics ---
[numthreads(NumThreads, 1, 1)]
void UpdateBoids(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    float2 pos = PredictedPositions[id.x];
    float2 myVel = Velocities[id.x];
    int2 originCell = GetCell2D(pos, sensorRadius);
    
    float2 pressureForce = 0;
    float2 viscosityForce = 0;
    float2 colForce = 0;
    float avgY = 0;
    int neighborCount = 0;
    
    float searchRad = max(sensorRadius, collisionRadius * 2.01);

    for (int i = 0; i < 9; i++)
    {
        uint hash = HashCell2D(originCell + offsets2D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];

        while (currIndex < numParticles)
        {
            uint3 indexData = SpatialIndices[currIndex];
            currIndex++;

            if (indexData[2] != key)
                break;
            if (indexData[1] != hash)
                continue;
            if (indexData[0] == id.x)
                continue;

            uint neighborIndex = indexData[0];
            float2 neighborPos = PredictedPositions[neighborIndex];
            float2 offset = neighborPos - pos;
            float sqrDst = dot(offset, offset);
            
            if (sqrDst < searchRad * searchRad)
            {
                float dst = sqrt(sqrDst);
                if (dst > 0.0001)
                {
                    // ------------------------------------------------------------------
                    // LAYER 1: PHYSICAL BODY (Granular Physics)
                    // ------------------------------------------------------------------
                    // Forcibly prevents overlap, mimicking granular material.
                    float minDst = collisionRadius * 2.0;
                    if (dst < minDst)
                    {
                        float kick = (minDst - dst) / minDst;
                        // Penalty Force: A stiff spring that kicks particles apart if they touch.
                        // FUTURE ABM: Keep this layer constant (physics) but change the
                        // collisionRadius based on agent type (e.g., Truck vs Car).
                        colForce -= (offset / dst) * (kick * kick * collisionStiffness);
                    }
                
                    // ------------------------------------------------------------------
                    // LAYER 2: AGENT BEHAVIOR (boids-like steering expressed as forces)
                    // ------------------------------------------------------------------
                    // Uses fluid-style terms (pressure/viscosity) that map roughly to separation/alignment.
                    // This represents the "Decision Making" or "Social" layer.
                    // Agents use sensors to look at neighbors and decide how to steer.
                    if (dst < sensorRadius)
                    {
                        neighborCount++;

                        // A. COHESION (Social Gathering, not full cohesion yet)
                        // Currently related to cohesion only in the sense that it act as "Vertical Support" to keep the pile upright,
                        //  is not implemented in the classic center-of-mass sense here.
                        // FUTURE ABM: Calculate full center-of-mass (avgX, avgY) to make agents clump together.
                        avgY += neighborPos.y;

                        // B. SEPARATION (Personal Space)
                        // "pressure" ~ separation (move away from crowding)
                        pressureForce -= (offset / dst) * (1.0 / dst);

                        // C. ALIGNMENT (Peer Pressure)
                        // "viscosity" ~ alignment (match neighbor velocity) 
                        viscosityForce += (Velocities[neighborIndex] - myVel) / dst;
                    }
                }
            }
        }
    }

    float2 totalForce = 0;

    // 1. APPLY PHYSICAL CONSTRAINTS
    totalForce += colForce;

    // 2. APPLY BEHAVIORAL STEERING (Conditional)
    if (neighborCount > 0)
    {
        
        
        // DENSITY CONSTRAINT (Social Comfort)
        // Acts like a feedback controller: only apply separation-like pressure when
        //   neighborCount exceeds idealNeighborCount (a target local density).
        float densityError = neighborCount - idealNeighborCount;
        if (densityError > 0)
            totalForce += pressureForce * pressureMultiplier * densityError;
        // FUTURE ABM: This could be state-dependent logic:
        //  if (isScared) idealNeighborCount = 0; // Flee everyone
        //  if (isCold) idealNeighborCount = 20;  // Huddle together

        // Apply Alignment (Viscosity)
        totalForce += viscosityForce * viscosity;

        // Apply Cohesion (Vertical Stability)
        avgY /= neighborCount;
        float yOffset = avgY - pos.y;
        totalForce += float2(0, yOffset * verticalSupport);
    }

    // Global Damping (Atmosphere/Friction)
    totalForce -= myVel * drag;

    // MOTOR LIMITS
    // Agents have a maximum force they can exert (muscle strength)
    if (length(totalForce) > maxForce)
        totalForce = normalize(totalForce) * maxForce;

    Velocities[id.x] += totalForce * deltaTime;

    // SPEED LIMITS
    // Agents have a physical speed limit
    if (length(Velocities[id.x]) > maxSpeed)
        Velocities[id.x] = normalize(Velocities[id.x]) * maxSpeed;

    Densities[id.x] = float2(neighborCount, 0);
}

// --- Kernel 4: Integration ---
[numthreads(NumThreads, 1, 1)]
void UpdatePositions(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    Positions[id.x] += Velocities[id.x] * deltaTime;
    
    // Bounds Check
    float2 pos = Positions[id.x];
    float2 vel = Velocities[id.x];
    const float2 halfSize = boundsSize * 0.5;
    float2 edgeDst = halfSize - abs(pos);

    if (edgeDst.x <= 0)
    {
        pos.x = halfSize.x * sign(pos.x);
        vel.x *= -1 * wallBounciness;
    }
    if (edgeDst.y <= 0)
    {
        pos.y = halfSize.y * sign(pos.y);
        vel.y *= -1 * wallBounciness;
    }

    Positions[id.x] = pos;
    Velocities[id.x] = vel;
}